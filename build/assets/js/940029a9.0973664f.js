"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[91877],{12575:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var r=t(74848),a=t(28453);const s={title:"Supra VRF",description:"Supra VRF provides smart contracts with a secure and decentralized source of randomness that is unbiasable, unpredictable, and publicly verifiable.",keywords:["SupraOracles","verifiable random function","random number generation"]},i=void 0,o={id:"tools/oracles/supraoracles/vrf",title:"Supra VRF",description:"Supra VRF provides smart contracts with a secure and decentralized source of randomness that is unbiasable, unpredictable, and publicly verifiable.",source:"@site/docs/tools/oracles/supraoracles/vrf.md",sourceDirName:"tools/oracles/supraoracles",slug:"/tools/oracles/supraoracles/vrf",permalink:"/tools/oracles/supraoracles/vrf",draft:!1,unlisted:!1,editUrl:"https://github.com/gnosischain/documentation/tree/main/docs/tools/oracles/supraoracles/vrf.md",tags:[],version:"current",lastUpdatedBy:"Dee",lastUpdatedAt:1705404574,formattedLastUpdatedAt:"Jan 16, 2024",frontMatter:{title:"Supra VRF",description:"Supra VRF provides smart contracts with a secure and decentralized source of randomness that is unbiasable, unpredictable, and publicly verifiable.",keywords:["SupraOracles","verifiable random function","random number generation"]},sidebar:"tools",previous:{title:"SupraOracles",permalink:"/tools/oracles/supraoracles/"},next:{title:"Liquid Staking",permalink:"/tools/beacon-chain/liquid-staking"}},c={},l=[{value:"What is a Verifiable Random Function (VRF)?",id:"what-is-a-verifiable-random-function-vrf",level:2},{value:"How to use SupraOracles&#39; VRF",id:"how-to-use-supraoracles-vrf",level:2},{value:"Step 1: Create The Supra Router Contract Interface",id:"step-1-create-the-supra-router-contract-interface",level:3},{value:"Step 2: Configure the Supra Router Contract Address",id:"step-2-configure-the-supra-router-contract-address",level:3},{value:"Step 3: Use the VRF service and request a Random Number",id:"step-3-use-the-vrf-service-and-request-a-random-number",level:3},{value:"Step 4 - Add the validation in the callback function of requester contract",id:"step-4---add-the-validation-in-the-callback-function-of-requester-contract",level:3},{value:"Example Implementation",id:"example-implementation",level:3},{value:"SupraOracles community channels",id:"supraoracles-community-channels",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.admonition,{title:"testnet",type:"info",children:(0,r.jsxs)(n.p,{children:["SupraOracles only supports ",(0,r.jsx)(n.a,{href:"../../../concepts/networks/chiado.md",children:"Chiado testnet"}),"."]})}),"\n",(0,r.jsx)(n.h2,{id:"what-is-a-verifiable-random-function-vrf",children:"What is a Verifiable Random Function (VRF)?"}),"\n",(0,r.jsx)(n.p,{children:"Blockchain-based verifiable random functions (VRFs) enable the generation of numbers that are as good as random (pseudorandom), and can be (publicly) verified cryptographically. Pseudorandomness guarantees both unpredictability and fairness, whereas tamper-proofness is guaranteed by their public verifiability."}),"\n",(0,r.jsxs)(n.p,{children:["Using a VRF for random number generation (RNG) is the gold standard for on-chain applications that require these properties, such as gaming operations, NFT-minting, lotteries, and randomized processes. More information about ",(0,r.jsx)(n.a,{href:"https://supraoracles.com/",children:"Supra"})," VRF can be found ",(0,r.jsx)(n.a,{href:"https://supraoracles.com/docs/vrf1",children:"here"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"how-to-use-supraoracles-vrf",children:"How to use SupraOracles' VRF"}),"\n",(0,r.jsx)(n.p,{children:"SupraOracles currently supports many Solidity/EVM-based networks, like Gnosis Chiado TestNet."}),"\n",(0,r.jsxs)(n.p,{children:["To see all of the networks SupraOracles supports, please visit ",(0,r.jsx)(n.a,{href:"https://supraoracles.com/docs/vrf1/network-addresses",children:"SupraOracles' Networks"})]}),"\n",(0,r.jsxs)(n.p,{children:["To get started, you will want to visit ",(0,r.jsx)(n.a,{href:"https://supraoracles.com/docs/vrf1",children:"SupraOracles' docs site"})," and review the documentation or continue to follow this guide for a quick start."]}),"\n",(0,r.jsx)(n.h3,{id:"step-1-create-the-supra-router-contract-interface",children:"Step 1: Create The Supra Router Contract Interface"}),"\n",(0,r.jsx)(n.p,{children:"Add the following code to the requester contract i.e, the contract which uses VRF as a service. You can also add the code in a separate Interface and inherit the interface in the requester contract."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"interface ISupraRouter { \n    function generateRequest(string memory _functionSig , uint8 _rngCount, uint256 _numConfirmations) external returns(uint256); \n    function generateRequest(string memory _functionSig , uint8 _rngCount, uint256 _numConfirmations, uint256 _clientSeed) external returns(uint256); \n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This interface will help the requester contract interact with the Supra Router contract and through which the requester contract can use the VRF service."}),"\n",(0,r.jsx)(n.h3,{id:"step-2-configure-the-supra-router-contract-address",children:"Step 2: Configure the Supra Router Contract Address"}),"\n",(0,r.jsx)(n.p,{children:"Contracts that need random numbers should utilize the Supra Router Contract. In order to do that, they need to create an interface and bind it to the on-chain address of the Supra Router contract."}),"\n",(0,r.jsx)(n.p,{children:"For Gnosis Chiado TestNet, the address is:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"0xb2667190b753720188a4039dd2b6014f01e07fea\n"})}),"\n",(0,r.jsx)(n.p,{children:"We\u2019ll store the set the address within the constructor and use it later to interact with the interface."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"contract ExampleContract {\n    address supraAddr;\n\n    constructor() {\n        supraAddr = 0xb2667190b753720188a4039dd2b6014f01e07fea;\n    }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-3-use-the-vrf-service-and-request-a-random-number",children:"Step 3: Use the VRF service and request a Random Number"}),"\n",(0,r.jsx)(n.p,{children:'In this step, we\'ll use the \u201cgenerateRequest\u201d function of the Supra Router Contract to create a request for random numbers. There are two modes for the "generateRequest" function. The only difference between them is that you can optionally provide a client-side input, which will also be part of the payload being threshold signed to provide randomness.'}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"_functionSig"})," - a string parameter, here the requester contract will have to pass the function signature which will receive the callback i.e., a random number from the Supra Router Contract. The function signature should be in the form of the function name following the parameters it accepts. We'll see an example later in the document."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"_rngCount"})," - an integer parameter, it is for the number of random numbers a particular requester wants to generate. Currently, we can generate a maximum of 255 random numbers per request."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"numConfirmations"})," - an integer parameter that specifies the number of block confirmations needed before supra VRF can generate the random number."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"_clientSeed"})," (optional) - an optional integer parameter that could be provided by the client (defaults to 0). This is for additional unpredictability. The source of the seed can be a UUID of 256 bits. This can also be from a centralized source.\nSupra's VRF process requires splitting the contract logic into two functions."]}),"\n",(0,r.jsx)(n.li,{children:"The request function - the signature of this function is up to the developer"}),"\n",(0,r.jsxs)(n.li,{children:["The callback function - the signature must be of the form ",(0,r.jsx)(n.strong,{children:"\u201cuint256 nonce, uint256[] calldata rngList\u201d"})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"function exampleRNG() external {  \n     //Function validation and logic\n     // requesting 10 random numbers\n     uint8 rngCount = 10; \n\n     // we want to wait for 1 confirmation before the request is considered complete/final\n     uint256 numConfirmations = 1; \n     uint256 generated_nonce = ISupraRouter(supraAddr).generateRequest(\u201cexampleCallback(uint256,uint256[])\u201d, rngCount, numConfirmations);\n\n     // store generated_nonce if necessary (eg: in a hashmap)\n     // this can be used to track parameters related to the request, such as user address, nft address etc in a lookup table\n     // these can be accessed inside the callback since the response from supra will include the nonce\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"step-4---add-the-validation-in-the-callback-function-of-requester-contract",children:"Step 4 - Add the validation in the callback function of requester contract"}),"\n",(0,r.jsx)(n.p,{children:"Inside the callback function where the requester contract wants the random number (in this example the callback function is exampleCallback), the requester contract will have to add the validation such that only the Supra router contract can call the function. The validation is necessary to protect against malicious contracts/users executing the callback with fake data."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:"function exampleCallback(uint256 _nonce ,uint256[] _rngList) external {\n    require(msg.sender == supraAddr);\n    // Following the required logic of the function\n }\n"})}),"\n",(0,r.jsx)(n.h3,{id:"example-implementation",children:"Example Implementation"}),"\n",(0,r.jsx)(n.p,{children:"In the example below,"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The function getRNGForUser is using the VRF service by calling the generateRequest function of the Supra Router Contract."}),"\n",(0,r.jsx)(n.li,{children:"Then we store the username of the user requesting the random number mapped to the nonce returned by generateRequest."}),"\n",(0,r.jsx)(n.li,{children:"Then the callback function prints the random numbers requested by a specific user and it has the signature: myCallbackUsername(uint256 nonce, uint256[] calldata rngList)\nOnce Supra generates the random number and it is verified by the on-chain logic to be authentic, myCallbackUsername is executed by the Supra Router, which completes the second half of the process. The nonce from the first argument is used to look up the username that originated the request."}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\ninterface ISupraRouter {\n   function generateRequest(string memory _functionSig , uint8 _rngCount, uint256 _numConfirmations, uint256 _clientSeed) external returns(uint256);\n   function generateRequest(string memory _functionSig , uint8 _rngCount, uint256 _numConfirmations) external returns(uint256);\n}\n\ncontract Interaction {\n   address supraAddr;\n   constructor() {\n       supraAddr = 0xb2667190b753720188a4039dd2b6014f01e07fea;\n   }\n\n   mapping (uint256 => string ) result;\n   mapping (string => uint256[] ) rngForUser;\n\n   function getRNGForUser(uint8 rngCount, string memory username) external {\n      uint256 nonce =  ISupraRouter(supraAddr).generateRequest("myCallbackUsername(uint256,uint256[])", rngCount, 1, 123);\n      result[nonce] = username;\n   }\n\n   function myCallbackUsername(uint256 nonce, uint256[] calldata rngList) external {\n      require(msg.sender == supraAddr, "only supra router can call this function");\n      uint8 i = 0;\n      uint256[] memory x = new uint256[](rngList.length);\n      rngForUser[result[nonce]] = x;\n      for(i=0; i<rngList.length;i++){\n         rngForUser[result[nonce]][i] = rngList[i] % 100;\n      }\n   }\n   \n   function viewUserName(string memory username) external view returns (uint256[] memory) {\n      return rngForUser[username];\n   }\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["For additional tutorials and guides based on example use-cases, please refer to the ",(0,r.jsx)(n.a,{href:"https://supraoracles.com/docs/additional-guides",children:"Supra Docs"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"supraoracles-community-channels",children:"SupraOracles community channels"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://supraoracles.com",children:"supraoracles.com"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://supraoracles.com/docs/overview",children:"Docs"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://t.me/SupraOracles",children:"Telegram"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://twitter.com/SupraOracles",children:"Twitter"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://discord.gg/supraoracles",children:"Discord"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"https://www.youtube.com/SupraOfficial",children:"Youtube"})}),"\n"]})]})}function d(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var r=t(96540);const a={},s=r.createContext(a);function i(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);