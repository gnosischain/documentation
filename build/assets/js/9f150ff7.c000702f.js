"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[90803],{65710:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>i,metadata:()=>a,toc:()=>c});var r=n(74848),o=n(28453);const i={title:"Token Registry",description:"Discover the token contract on the Ethereum Mainnet that corresponds to the token contract on Gnosis chain.",keywords:["token registry","bridged tokens","canonical token","gnosis bridge"]},s="Token Registry",a={id:"bridges/tutorials/using-omnibridge/token-registry",title:"Token Registry",description:"Discover the token contract on the Ethereum Mainnet that corresponds to the token contract on Gnosis chain.",source:"@site/docs/bridges/tutorials/using-omnibridge/token-registry.md",sourceDirName:"bridges/tutorials/using-omnibridge",slug:"/bridges/tutorials/using-omnibridge/token-registry",permalink:"/bridges/tutorials/using-omnibridge/token-registry",draft:!1,unlisted:!1,editUrl:"https://github.com/gnosischain/documentation/tree/main/docs/bridges/tutorials/using-omnibridge/token-registry.md",tags:[],version:"current",lastUpdatedBy:"zengzengzenghuy",lastUpdatedAt:1690538497,formattedLastUpdatedAt:"Jul 28, 2023",frontMatter:{title:"Token Registry",description:"Discover the token contract on the Ethereum Mainnet that corresponds to the token contract on Gnosis chain.",keywords:["token registry","bridged tokens","canonical token","gnosis bridge"]},sidebar:"bridges",previous:{title:"OmniBridge Basics",permalink:"/bridges/tutorials/using-omnibridge/"},next:{title:"Specific Tokens",permalink:"/bridges/tutorials/using-omnibridge/specific-tokens"}},d={},c=[{value:"Getting corresponding Token Address",id:"getting-corresponding-token-address",level:2},{value:"<strong>Approach 1: BlockScout</strong>",id:"approach-1-blockscout",level:3},{value:"<strong>Approach 2: Mediator Storage</strong>",id:"approach-2-mediator-storage",level:3},{value:"Verifying a Canonical Bridged Token on BlockScout",id:"verifying-a-canonical-bridged-token-on-blockscout",level:2},{value:"Bridged Tokens List",id:"bridged-tokens-list",level:2},{value:"Getting bridged tokens from Omnibridge Smart Contracts",id:"getting-bridged-tokens-from-omnibridge-smart-contracts",level:2}];function l(e){const t={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components},{Details:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Details",!0),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"token-registry",children:"Token Registry"}),"\n",(0,r.jsx)(t.h2,{id:"getting-corresponding-token-address",children:"Getting corresponding Token Address"}),"\n",(0,r.jsx)(t.p,{children:"There are several approaches to discover the token contract on the Ethereum Mainnet that corresponds to the token contract on Gnosis chain."}),"\n",(0,r.jsx)(t.h3,{id:"approach-1-blockscout",children:(0,r.jsx)(t.strong,{children:"Approach 1: BlockScout"})}),"\n",(0,r.jsxs)(t.p,{children:["BlockScout allows you to see if a token was bridged using the multi-token extension. First, search the token and go it's contract page:\r\n",(0,r.jsx)(t.img,{src:n(56488).A+"",width:"1347",height:"527"}),"\r\nThis view contains information that this token was bridged and a link to the original token.\r\n",(0,r.jsx)(t.img,{src:n(41763).A+"",width:"1236",height:"107"}),"\r\nIf you go to the top bar, you will notice that the token dropdown allows you to filter between tokens based off where they were bridged from:\r\n",(0,r.jsx)(t.img,{src:n(24186).A+"",width:"1343",height:"227"})]}),"\n",(0,r.jsx)(t.h3,{id:"approach-2-mediator-storage",children:(0,r.jsx)(t.strong,{children:"Approach 2: Mediator Storage"})}),"\n",(0,r.jsxs)(t.p,{children:["The ",(0,r.jsx)(t.a,{href:"https://gnosisscan.io/address/0xf6A78083ca3e2a662D6dd1703c939c8aCE2e268d#writeProxyContract",children:"multi-token mediator on Gnosis chain"})," provides methods for viewing correspondence of bridgeable tokens:"]}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"foreignTokenAddress"})," - returns the address of the token contract on the Ethereum Mainnet by specifying the address the token contract on Gnosis Chain."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.code,{children:"homeTokenAddress"}),"- returns the address of the token contract on Gnosis chain by specifying the address of the token contract on Ethereum.\r\nPass in the token address to get the corresponding address on the other chain:",(0,r.jsx)(t.br,{}),"\n",(0,r.jsx)(t.img,{src:n(50438).A+"",width:"1243",height:"1034"})]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"verifying-a-canonical-bridged-token-on-blockscout",children:"Verifying a Canonical Bridged Token on BlockScout"}),"\n",(0,r.jsx)(t.p,{children:"New tokens deployed by the multi-token mediator are not verified automatically in BlockScout. Sometimes it is necessary to read data from the token contract directly in the block explorer or even call a method of the token contract (e.g. to transfer tokens back to the Ethereum Mainnet). Follow the instructions below to verify the contract in BlockScout. Once verified, you can read and write to the contract using the BlockScout interface."}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["Find the token contract by the token symbol using the search bar. The following example follows the verification of the STAKE token, which ",(0,r.jsx)(t.a,{href:"https://forum.gnosis.io/t/gip-16-gnosis-chain-xdai-gnosis-merge/1904",children:"recently had its staking utility deprecated"}),'. However, these steps are still relevant. The bridgeable token name is extended by "on xDai":\r\n',(0,r.jsx)(t.img,{src:n(65773).A+"",width:"790",height:"194"})]}),"\n",(0,r.jsxs)(t.li,{children:["Verify the contract:\r\n",(0,r.jsx)(t.img,{src:n(84150).A+"",width:"1243",height:"317"}),"\r\n",(0,r.jsx)(t.img,{src:n(80479).A+"",width:"1242",height:"310"}),'\r\nClick on the Code tab, click Verify and Publish, then fill the form following the recommendations below (see solidity contract code below this image). Press the "Verify & publish" button at the bottom of the form to finish.\r\n',(0,r.jsx)(t.img,{src:n(29152).A+"",width:"920",height:"1009"})]}),"\n"]}),"\n",(0,r.jsxs)(i,{children:[(0,r.jsx)("summary",{children:"Click to View Solidity Contract Code used in the Example"}),(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Code"}),":"]}),(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-solidity",metastring:"showLineNumbers",children:"\r\n  pragma solidity 0.4.24;\r\n\r\n  /**\r\n  * @title Proxy\r\n  * @dev Gives the possibility to delegate any call to a foreign implementation.\r\n  */\r\n  contract Proxy {\r\n      /**\r\n      * @dev Tells the address of the implementation where every call will be delegated.\r\n      * @return address of the implementation to which it will be delegated\r\n      */\r\n      /* solcov ignore next */\r\n      function implementation() public view returns (address);\r\n\r\n      /**\r\n      * @dev Fallback function allowing to perform a delegatecall to the given implementation.\r\n      * This function will return whatever the implementation call returns\r\n      */\r\n      function() public payable {\r\n          // solhint-disable-previous-line no-complex-fallback\r\n          address _impl = implementation();\r\n          require(_impl != address(0));\r\n          assembly {\r\n              /*\r\n                  0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40)\r\n                  loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty\r\n                  memory. It's needed because we're going to write the return data of delegatecall to the\r\n                  free memory slot.\r\n              */\r\n              let ptr := mload(0x40)\r\n              /*\r\n                  `calldatacopy` is copy calldatasize bytes from calldata\r\n                  First argument is the destination to which data is copied(ptr)\r\n                  Second argument specifies the start position of the copied data.\r\n                      Since calldata is sort of its own unique location in memory,\r\n                      0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata.\r\n                      That's always going to be the zeroth byte of the function selector.\r\n                  Third argument, calldatasize, specifies how much data will be copied.\r\n                      calldata is naturally calldatasize bytes long (same thing as msg.data.length)\r\n              */\r\n              calldatacopy(ptr, 0, calldatasize)\r\n              /*\r\n                  delegatecall params explained:\r\n                  gas: the amount of gas to provide for the call. `gas` is an Opcode that gives\r\n                      us the amount of gas still available to execution\r\n\r\n                  _impl: address of the contract to delegate to\r\n\r\n                  ptr: to pass copied data\r\n\r\n                  calldatasize: loads the size of `bytes memory data`, same as msg.data.length\r\n\r\n                  0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic,\r\n                          these are set to 0, 0 so the output data will not be written to memory. The output\r\n                          data will be read using `returndatasize` and `returdatacopy` instead.\r\n\r\n                  result: This will be 0 if the call fails and 1 if it succeeds\r\n              */\r\n              let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0)\r\n              /*\r\n\r\n              */\r\n              /*\r\n                  ptr current points to the value stored at 0x40,\r\n                  because we assigned it like ptr := mload(0x40).\r\n                  Because we use 0x40 as a free memory pointer,\r\n                  we want to make sure that the next time we want to allocate memory,\r\n                  we aren't overwriting anything important.\r\n                  So, by adding ptr and returndatasize,\r\n                  we get a memory location beyond the end of the data we will be copying to ptr.\r\n                  We place this in at 0x40, and any reads from 0x40 will now read from free memory\r\n              */\r\n              mstore(0x40, add(ptr, returndatasize))\r\n              /*\r\n                  `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the\r\n                      slot it will copy to, 0 means copy from the beginning of the return data, and size is\r\n                      the amount of data to copy.\r\n                  `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall\r\n              */\r\n              returndatacopy(ptr, 0, returndatasize)\r\n\r\n              /*\r\n                  if `result` is 0, revert.\r\n                  if `result` is 1, return `size` amount of data from `ptr`. This is the data that was\r\n                  copied to `ptr` from the delegatecall return data\r\n              */\r\n              switch result\r\n                  case 0 {\r\n                      revert(ptr, returndatasize)\r\n                  }\r\n                  default {\r\n                      return(ptr, returndatasize)\r\n                  }\r\n          }\r\n      }\r\n  }\r\n\r\n  interface IPermittableTokenVersion {\r\n      function version() external pure returns (string);\r\n  }\r\n\r\n  /**\r\n  * @title TokenProxy\r\n  * @dev Helps to reduces the size of the deployed bytecode for automatically created tokens, by using a proxy contract.\r\n  */\r\n  contract TokenProxy is Proxy {\r\n      // storage layout is copied from PermittableToken.sol\r\n      string internal name;\r\n      string internal symbol;\r\n      uint8 internal decimals;\r\n      mapping(address => uint256) internal balances;\r\n      uint256 internal totalSupply;\r\n      mapping(address => mapping(address => uint256)) internal allowed;\r\n      address internal owner;\r\n      bool internal mintingFinished;\r\n      address internal bridgeContractAddr;\r\n      // string public constant version = \"1\";\r\n      bytes32 internal DOMAIN_SEPARATOR;\r\n      // bytes32 public constant PERMIT_TYPEHASH = 0xea2aa0a1be11a07ed86d755c93467f4f82362b452371d1ba94d1715123511acb;\r\n      mapping(address => uint256) internal nonces;\r\n      mapping(address => mapping(address => uint256)) internal expirations;\r\n\r\n      /**\r\n      * @dev Creates a non-upgradeable token proxy for PermitableToken.sol, initializes its eternalStorage.\r\n      * @param _tokenImage address of the token image used for mirrowing all functions.\r\n      * @param _name token name.\r\n      * @param _symbol token symbol.\r\n      * @param _decimals token decimals.\r\n      * @param _chainId chain id for current network.\r\n      */\r\n      constructor(address _tokenImage, string memory _name, string memory _symbol, uint8 _decimals, uint256 _chainId)\r\n          public\r\n      {\r\n          string memory version = IPermittableTokenVersion(_tokenImage).version();\r\n\r\n          assembly {\r\n              // EIP 1967\r\n              // bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)\r\n              sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, _tokenImage)\r\n          }\r\n          name = _name;\r\n          symbol = _symbol;\r\n          decimals = _decimals;\r\n          owner = msg.sender; // msg.sender == HomeMultiAMBErc20ToErc677 mediator\r\n          bridgeContractAddr = msg.sender;\r\n          DOMAIN_SEPARATOR = keccak256(\r\n              abi.encode(\r\n                  keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                  keccak256(bytes(_name)),\r\n                  keccak256(bytes(version)),\r\n                  _chainId,\r\n                  address(this)\r\n              )\r\n          );\r\n      }\r\n\r\n      /**\r\n      * @dev Retrieves the implementation contract address, mirrowed token image.\r\n      * @return token image address.\r\n      */\r\n      function implementation() public view returns (address impl) {\r\n          assembly {\r\n              impl := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)\r\n          }\r\n      }\r\n  }\n"})})]}),"\n",(0,r.jsx)(t.p,{children:'After verification is successful, the number tabs in the contract window will be extended to allow users to "Read Contract", "Write Contract", "Read Proxy" and "Write Proxy".'}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{src:n(329).A+"",width:"1240",height:"506"})}),"\n",(0,r.jsx)(t.h2,{id:"bridged-tokens-list",children:"Bridged Tokens List"}),"\n",(0,r.jsx)(t.p,{children:"A dynamic list of bridged tokens is now available."}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:(0,r.jsx)(t.a,{href:"https://blockscout.com/xdai/mainnet/bridged-tokens/eth",children:"Tokens Bridged from Ethereum"})}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.a,{href:"https://blockscout.com/xdai/mainnet/bridged-tokens/bsc",children:"Tokens Bridged from Binance Smart Chain"}),(0,r.jsx)(t.br,{}),"\n",'The OmniBridge multi-token bridge extension is now being used to bridge many tokens from Ethereum to Gnosis. A second instance bridges tokens to and from the Binance Smart Chain. When a token is bridged, the name is appended with "on xDai" or "from Ethereum/BSC". On a token page, you can also find the link to the original token on Ethereum.']}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"getting-bridged-tokens-from-omnibridge-smart-contracts",children:"Getting bridged tokens from Omnibridge Smart Contracts"}),"\n",(0,r.jsx)(t.p,{children:"The Token list is queried dynamically with BlockScout. The list is compiled by following these steps:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["Find all transactions to the ",(0,r.jsx)(t.a,{href:"https://gnosis.blockscout.com/address/0x75Df5AF045d91108662D8080fD1FEFAd6aA0bb59/transactions#address-tabs",children:"AMB Contract on Gnosis"})]}),"\n",(0,r.jsx)(t.li,{children:"Check all internal transactions for each transaction."}),"\n",(0,r.jsxs)(t.li,{children:["If an internal transaction creates a contract from the AMB mediator address (0xf6A78083ca3e2a662D6dd1703c939c8aCE2e268d), and this contract exposes the ",(0,r.jsx)(t.code,{children:"getTokenInterfacesVersion()"})," getter, it is safe to assume that this contract\u2019s address is a bridged token address."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},56488:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/omni-bridged-tokens1-17e7ff3b8132daf9117de44d480df7de.png"},41763:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/omni-bridged-tokens2-a201b0826a31b3c2e2846af50c293dfb.png"},24186:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/omni-bridged-tokens3-b9cbb553036f1d836e09cae1b91bffd8.png"},50438:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/omni-mediatorstorage1-8130d097948f8c5d64ee47106415f9aa.png"},65773:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/omni-verify-token1-b086c5394a133c4acc2603ddbf1cddbc.png"},84150:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/omni-verify-token2-ae97e7ec7578f492d760d58443de1e85.png"},80479:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/omni-verify-token3-cd4ee3e0e95a07acab800d51f051dafb.png"},29152:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/omni-verify-token4-da664b66ed9fb463e9ad04307cfb124f.png"},329:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/omni-verify-token5-f8640c44061174d05e8defda0e9fce1e.png"},28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var r=n(96540);const o={},i=r.createContext(o);function s(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);