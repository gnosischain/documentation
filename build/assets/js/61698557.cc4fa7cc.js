"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[85266],{74996:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var t=s(74848),a=s(28453);const i={title:"Core Devs Call - 2023/06/14",authors:["dapplion","armaganercan"],tags:["CoreDevsCall","gnosis"]},o="Gnosis Core Devs Call Notes",r={permalink:"/updates/2023/06/14/core-devs-call",source:"@site/updates/2023/06-14-core-devs-call.md",title:"Core Devs Call - 2023/06/14",description:"june 14",date:"2023-06-14T00:00:00.000Z",formattedDate:"June 14, 2023",tags:[{label:"CoreDevsCall",permalink:"/updates/tags/core-devs-call"},{label:"gnosis",permalink:"/updates/tags/gnosis"}],readingTime:1.925,hasTruncateMarker:!1,authors:[{name:"Lion - dapplion",title:"Merge coordinator",url:"https://github.com/dapplion",imageURL:"https://avatars.githubusercontent.com/u/35266934",key:"dapplion"},{name:"0xarmagan",title:"Validator Comms Lead @ Gnosis",url:"https://github.com/0xarmagan",imageURL:"https://avatars.githubusercontent.com/u/75987728",key:"armaganercan"}],frontMatter:{title:"Core Devs Call - 2023/06/14",authors:["dapplion","armaganercan"],tags:["CoreDevsCall","gnosis"]},unlisted:!1,prevItem:{title:"Core Devs Call - 2023/06/21",permalink:"/updates/2023/06/21/core-devs-call"},nextItem:{title:"Core Devs Call - 2023/06/07",permalink:"/updates/2023/06/07/core-devs-call"}},l={authorsImageUrls:[void 0,void 0]},c=[{value:"EL",id:"el",level:2},{value:"CL",id:"cl",level:2}];function d(e){const n={a:"a",h1:"h1",h2:"h2",img:"img",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{src:"https://github.com/gnosischain/documentation-1/assets/75987728/38db4350-4c5d-4da8-a29c-9129ae069841",alt:"june 14"})}),"\n",(0,t.jsx)(n.p,{children:"Welcome to the weekly Gnosis Core Devs Call, where members of the Gnosis team and contributors gather to discuss the latest developments and updates related to the Gnosis ecosystem. This meeting is held every Wednesday and serves as a platform for participants to collaborate and exchange ideas."}),"\n",(0,t.jsx)(n.p,{children:"The participants of this call include representatives from various teams such as Erigon, Gateway, Nethermind, Geth, Gnosis DevOps, Gnosis Core Devs, Gnosis DevRels, Gnosis Comms team, and community contributors. The presence of diverse team members ensures that discussions are comprehensive and informative, with insights from multiple perspectives."}),"\n",(0,t.jsxs)(n.p,{children:["For those who missed the live meeting, ",(0,t.jsx)(n.a,{href:"https://youtu.be/DjkAugZ-ONY",children:"a full recording is available on YouTube"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The Gnosis Core Devs Call is a crucial component of the Gnosis ecosystem. It provides an opportunity for participants to stay informed, share ideas and collaborate, thus driving innovation and progress within the Gnosis community."}),"\n",(0,t.jsx)(n.p,{children:"June 14, 2023"}),"\n",(0,t.jsx)(n.h1,{id:"client-team-updates",children:"Client Team Updates"}),"\n",(0,t.jsx)(n.h2,{id:"el",children:"EL"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Nethermind"}),": Working on the shapella todo list. They will take a look at the new contract."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Erigon"}),": No updates."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Geth"}),": No updates."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"cl",children:"CL"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Prysm"}),": No updates."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Nimbus"}),": No updates."]}),"\n"]}),"\n",(0,t.jsx)(n.h1,{id:"chain-infra",children:"Chain Infra"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Gateway"})," : Fixed the launchpad."]}),"\n",(0,t.jsx)(n.h1,{id:"withdrawals",children:"Withdrawals"}),"\n",(0,t.jsxs)(n.p,{children:["GNew contract: ",(0,t.jsx)(n.a,{href:"https://github.com/gnosischain/deposit-contract/pull/45",children:"https://github.com/gnosischain/deposit-contract/pull/45"}),"\nAudit in progress\nVery basic"]}),"\n",(0,t.jsx)(n.h1,{id:"to-do",children:"To-do"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"New devnet"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"50/50 Nethermind + Erigon"}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Shadowfork\nBe careful with the contract upgrades because we can get replayed. What are we trying to achieve with this fork? What are the questions we want to answer? We can also disregard this but spam the devnet with a lot of transactions instead so we have more accurate blocks instead of empty ones. The way it worked for Ethereum. Sync mainnet and stop ELs on some block. Take that hash in the beacon chain genesis. Spin up a new beacon chain with shapella scheduled. We also need to upgrade the contract. We can get replayed. We can also deploy the contracts now. (before the shadow fork) As long as we coordinate around deposit UI changes."}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Upgrade contract on Chiado\nDeposit UIs"}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Mainnet\nMake sure that enough core devs are available because the holiday season is going to start"}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.h1,{id:"hive",children:"Hive"}),"\n",(0,t.jsx)(n.p,{children:"Added more tests to the previous suites. Everything is working. Started to add Erigon, Marcos is in touch with Andrew to fix remaining issues"})]})}function h(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},28453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>r});var t=s(96540);const a={},i=t.createContext(a);function o(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);